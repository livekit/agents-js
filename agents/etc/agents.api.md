## API Report File for "@livekit/agents"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { AudioFrame } from '@livekit/rtc-node';
import type { AudioSource } from '@livekit/rtc-node';
import type { E2EEOptions } from '@livekit/rtc-node';
import { EventEmitter } from 'node:events';
import { JobType } from '@livekit/protocol';
import type { LocalParticipant } from '@livekit/rtc-node';
import type { Logger } from 'pino';
import type * as proto from '@livekit/protocol';
import type { RemoteAudioTrack } from '@livekit/rtc-node';
import type { RemoteParticipant } from '@livekit/rtc-node';
import type { Room } from '@livekit/rtc-node';
import type { RtcConfiguration } from '@livekit/rtc-node';
import type { TrackSource } from '@livekit/protocol';
import { z } from 'zod';

// @public (undocumented)
export interface Agent {
    // (undocumented)
    entry: (ctx: JobContext) => Promise<void>;
    // (undocumented)
    prewarm?: (proc: JobProcess) => unknown;
}

// @public (undocumented)
const AGENT_STATE_ATTRIBUTE = "lk.agent.state";

// @public (undocumented)
class AgentPlayout extends EventEmitter {
    constructor(audioSource: AudioSource, sampleRate: number, numChannels: number, inFrameSize: number, outFrameSize: number);
    // Warning: (ae-incompatible-release-tags) The symbol "play" is marked as @public, but its signature references "AsyncIterableQueue" which is marked as @internal
    // Warning: (ae-incompatible-release-tags) The symbol "play" is marked as @public, but its signature references "AsyncIterableQueue" which is marked as @internal
    //
    // (undocumented)
    play(itemId: string, contentIndex: number, transcriptionFwd: TranscriptionForwarder, textStream: AsyncIterableQueue<string>, audioStream: AsyncIterableQueue<AudioFrame>): PlayoutHandle;
}

// @public (undocumented)
type AgentState = 'initializing' | 'thinking' | 'listening' | 'speaking';

// Warning: (ae-internal-missing-underscore) The name "AsyncIterableQueue" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class AsyncIterableQueue<T> implements AsyncIterable<T> {
    // (undocumented)
    [Symbol.asyncIterator](): AsyncIterator<T>;
    constructor();
    // (undocumented)
    close(): void;
    // (undocumented)
    put(item: T): void;
}

// @public
type AudioBuffer_2 = AudioFrame[] | AudioFrame;
export { AudioBuffer_2 as AudioBuffer }

// @public
export class AudioByteStream {
    constructor(sampleRate: number, numChannels: number, samplesPerChannel?: number | null);
    // (undocumented)
    flush(): AudioFrame[];
    // (undocumented)
    write(data: ArrayBuffer): AudioFrame[];
}

// @public
export enum AutoSubscribe {
    // (undocumented)
    AUDIO_ONLY = 3,
    // (undocumented)
    SUBSCRIBE_ALL = 0,
    // (undocumented)
    SUBSCRIBE_NONE = 1,
    // (undocumented)
    VIDEO_ONLY = 2
}

// @public (undocumented)
export class BasicTranscriptionForwarder implements TranscriptionForwarder {
    constructor(room: Room, participantIdentity: string, trackSid: string, messageId: string);
    // (undocumented)
    close(interrupt: boolean): Promise<void>;
    // (undocumented)
    currentCharacterIndex: number;
    // (undocumented)
    markAudioComplete(): void;
    // (undocumented)
    markTextComplete(): void;
    // (undocumented)
    pushAudio(frame: AudioFrame): void;
    // (undocumented)
    pushText(text: string): void;
    // (undocumented)
    start(): void;
}

// @public
interface CallableFunction_2<P extends z.ZodTypeAny = any, R = any> {
    // (undocumented)
    description: string;
    // (undocumented)
    execute: (args: inferParameters<P>) => PromiseLike<R>;
    // (undocumented)
    parameters: P;
}

// Warning: (ae-internal-missing-underscore) The name "CancellablePromise" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class CancellablePromise<T> {
    constructor(executor: (resolve: (value: T | PromiseLike<T>) => void, reject: (reason?: any) => void, onCancel: (cancelFn: () => void) => void) => void);
    // (undocumented)
    cancel(): void;
    // (undocumented)
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | null): Promise<T | TResult>;
    // (undocumented)
    get error(): Error | null;
    // (undocumented)
    finally(onfinally?: (() => void) | null): Promise<T>;
    // (undocumented)
    static from<T>(promise: Promise<T>): CancellablePromise<T>;
    // (undocumented)
    get isCancelled(): boolean;
    // (undocumented)
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | null): Promise<TResult1 | TResult2>;
}

// @public (undocumented)
abstract class ChunkedStream implements AsyncIterableIterator<SynthesizedAudio> {
    // (undocumented)
    [Symbol.asyncIterator](): ChunkedStream;
    // (undocumented)
    [Symbol.iterator](): ChunkedStream;
    // (undocumented)
    abstract close(): Promise<void>;
    // (undocumented)
    collect(): Promise<AudioFrame>;
    // (undocumented)
    abstract next(): Promise<IteratorResult<SynthesizedAudio>>;
}

declare namespace cli {
    export {
        runApp
    }
}
export { cli }

// Warning: (ae-internal-missing-underscore) The name "defaultInitializeProcessFunc" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const defaultInitializeProcessFunc: (_: JobProcess) => JobProcess;

// @public
export function defineAgent(agent: Agent): Agent;

// @public (undocumented)
export const findMicroTrackId: (room: Room, identity: string) => string;

// @public
type FunctionContext = {
    [name: string]: CallableFunction_2;
};

// @public
export class FunctionExistsError extends Error {
    constructor(msg?: string);
}

// Warning: (ae-internal-missing-underscore) The name "Future" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Future {
    constructor();
    // (undocumented)
    get await(): Promise<void>;
    // (undocumented)
    get done(): boolean;
    // (undocumented)
    reject(error: Error): void;
    // (undocumented)
    resolve(): void;
}

// Warning: (ae-internal-missing-underscore) The name "gracefullyCancel" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function gracefullyCancel<T>(promise: CancellablePromise<T>): Promise<void>;

// @public
type inferParameters<P extends z.ZodTypeAny> = z.infer<P>;

// Warning: (ae-internal-missing-underscore) The name "initializeLogger" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const initializeLogger: ({ pretty, level }: LoggerOptions) => void;

// Warning: (ae-internal-missing-underscore) The name "isAgent" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export function isAgent(obj: unknown): obj is Agent;

// @public (undocumented)
export type JobAcceptArguments = {
    name: string;
    identity: string;
    metadata: string;
};

// @public
export class JobContext {
    constructor(proc: JobProcess, info: RunningJobInfo, room: Room, onConnect: () => void, onShutdown: (s: string) => void);
    addParticipantEntrypoint(callback: (job: JobContext, p: RemoteParticipant) => Promise<void>): void;
    addShutdownCallback(callback: () => Promise<void>): void;
    // (undocumented)
    get agent(): LocalParticipant | undefined;
    connect(e2ee?: E2EEOptions, autoSubscribe?: AutoSubscribe, rtcConfig?: RtcConfiguration): Promise<void>;
    // (undocumented)
    get job(): proto.Job;
    // @internal (undocumented)
    onParticipantConnected(p: RemoteParticipant): void;
    // (undocumented)
    get proc(): JobProcess;
    // (undocumented)
    get room(): Room;
    shutdown(reason?: string): void;
    // @internal (undocumented)
    shutdownCallbacks: (() => Promise<void>)[];
    // (undocumented)
    waitForParticipant(identity?: string): Promise<RemoteParticipant>;
}

// @public (undocumented)
export class JobProcess {
    // (undocumented)
    get pid(): number;
    // (undocumented)
    userData: {
        [id: string]: unknown;
    };
}

// @public
export class JobRequest {
    // @internal
    constructor(job: proto.Job, onReject: () => Promise<void>, onAccept: (args: JobAcceptArguments) => Promise<void>);
    accept(name?: string, identity?: string, metadata?: string): Promise<void>;
    // (undocumented)
    get agentName(): string;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get job(): proto.Job;
    // (undocumented)
    get publisher(): proto.ParticipantInfo | undefined;
    reject(): Promise<void>;
    // (undocumented)
    get room(): proto.Room | undefined;
}

declare namespace llm {
    export {
        CallableFunction_2 as CallableFunction,
        FunctionContext,
        inferParameters,
        oaiParams
    }
}
export { llm }

// Warning: (ae-internal-missing-underscore) The name "log" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export const log: () => Logger;

// Warning: (ae-internal-missing-underscore) The name "LoggerOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type LoggerOptions = {
    pretty: boolean;
    level?: string;
};

// Warning: (ae-internal-missing-underscore) The name "loggerOptions" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export let loggerOptions: LoggerOptions;

// @public
export const mergeFrames: (buffer: AudioBuffer_2) => AudioFrame;

// @public
export class MissingCredentialsError extends Error {
    constructor(msg?: string);
}

declare namespace multimodal {
    export {
        RealtimeSession,
        RealtimeModel,
        AgentState,
        AGENT_STATE_ATTRIBUTE,
        MultimodalAgent,
        proto_2 as proto,
        PlayoutHandle,
        AgentPlayout
    }
}
export { multimodal }

// @beta (undocumented)
class MultimodalAgent extends EventEmitter {
    constructor({ model, fncCtx, }: {
        model: RealtimeModel;
        fncCtx?: llm.FunctionContext | undefined;
    });
    // (undocumented)
    get fncCtx(): llm.FunctionContext | undefined;
    set fncCtx(ctx: llm.FunctionContext | undefined);
    // (undocumented)
    linkedParticipant: RemoteParticipant | null;
    // (undocumented)
    model: RealtimeModel;
    // (undocumented)
    readMicroTask: {
        promise: Promise<void>;
        cancel: () => void;
    } | null;
    // (undocumented)
    room: Room | null;
    // (undocumented)
    start(room: Room, participant?: RemoteParticipant | string | null): Promise<RealtimeSession>;
    // (undocumented)
    subscribedTrack: RemoteAudioTrack | null;
}

// Warning: (ae-internal-missing-underscore) The name "Mutex" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Mutex {
    constructor(limit?: number);
    // (undocumented)
    isLocked(): boolean;
    // (undocumented)
    lock(): Promise<() => void>;
}

// @internal (undocumented)
const oaiParams: (p: z.AnyZodObject) => {
    type: "object";
    properties: Record<string, any>;
    required_properties: string[];
};

// @public (undocumented)
class PlayoutHandle extends EventEmitter {
    constructor(audioSource: AudioSource, sampleRate: number, itemId: string, contentIndex: number, transcriptionFwd: TranscriptionForwarder);
    // (undocumented)
    get audioSamples(): number;
    // (undocumented)
    get contentIndex(): number;
    // (undocumented)
    get done(): boolean;
    // @internal (undocumented)
    doneFut: Future;
    // (undocumented)
    interrupt(): void;
    // (undocumented)
    get interrupted(): boolean;
    // @internal (undocumented)
    intFut: Future;
    // (undocumented)
    get itemId(): string;
    // @internal (undocumented)
    pushedDuration: number;
    // (undocumented)
    get textChars(): number;
    // @internal (undocumented)
    totalPlayedTime: number | undefined;
    // @internal (undocumented)
    transcriptionFwd: TranscriptionForwarder;
}

// @public (undocumented)
abstract class Plugin_2 {
    constructor(title: string, version: string);
    // (undocumented)
    abstract downloadFiles(): void;
    // (undocumented)
    registeredPlugins: Plugin_2[];
    // (undocumented)
    static registerPlugins(plugin: Plugin_2): void;
    // (undocumented)
    get title(): string;
    // (undocumented)
    get version(): string;
}
export { Plugin_2 as Plugin }

// @public (undocumented)
const proto_2: {};

// Warning: (ae-internal-missing-underscore) The name "Queue" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Queue<T> {
    constructor(limit?: number);
    // (undocumented)
    get(): Promise<T>;
    // (undocumented)
    items: T[];
    // (undocumented)
    put(item: T): Promise<void>;
}

// @beta (undocumented)
abstract class RealtimeModel {
    // (undocumented)
    abstract close(): Promise<void>;
    // (undocumented)
    abstract inFrameSize: number;
    // (undocumented)
    abstract numChannels: number;
    // (undocumented)
    abstract outFrameSize: number;
    // (undocumented)
    abstract sampleRate: number;
    // (undocumented)
    abstract session(options: any): RealtimeSession;
}

// @beta (undocumented)
abstract class RealtimeSession extends EventEmitter {
    // (undocumented)
    abstract conversation: any;
    // (undocumented)
    abstract fncCtx: llm.FunctionContext | undefined;
    // (undocumented)
    abstract inputAudioBuffer: any;
}

// @public
const runApp: (opts: WorkerOptions_2) => void;

// @public (undocumented)
export type RunningJobInfo = {
    acceptArguments: JobAcceptArguments;
    job: proto.Job;
    url: string;
    token: string;
};

// @public (undocumented)
export interface SegmentedSentence {
    // (undocumented)
    text: string;
}

// @public (undocumented)
export abstract class SentenceStream implements IterableIterator<SegmentedSentence> {
    // (undocumented)
    [Symbol.iterator](): SentenceStream;
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    abstract flush(): Promise<void>;
    // (undocumented)
    abstract next(): IteratorResult<SegmentedSentence>;
    // (undocumented)
    abstract pushText(text: string): void;
}

// @public (undocumented)
export abstract class SentenceTokenizer {
    // (undocumented)
    abstract stream(language: string | undefined): SentenceStream;
    // (undocumented)
    abstract tokenize(text: string, language?: string): SegmentedSentence[];
}

// @public (undocumented)
interface SpeechData {
    // (undocumented)
    confidence: number;
    // (undocumented)
    endTime: number;
    // (undocumented)
    language: string;
    // (undocumented)
    startTime: number;
    // (undocumented)
    text: string;
}

// @public (undocumented)
class SpeechEvent {
    constructor(type: SpeechEventType, alternatives?: SpeechData[]);
    // (undocumented)
    alternatives: SpeechData[];
    // (undocumented)
    type: SpeechEventType;
}

// @public (undocumented)
enum SpeechEventType {
    END_OF_SPEECH = 3,
    FINAL_TRANSCRIPT = 2,
    INTERIM_TRANSCRIPT = 1,
    START_OF_SPEECH = 0
}

// @public (undocumented)
abstract class SpeechStream implements IterableIterator<SpeechEvent> {
    // (undocumented)
    [Symbol.iterator](): SpeechStream;
    abstract close(wait: boolean): Promise<void>;
    // (undocumented)
    abstract next(): IteratorResult<SpeechEvent>;
    abstract pushFrame(token: AudioFrame): void;
}

// @public (undocumented)
class StreamAdapter extends STT {
    constructor(stt: STT, vadStream: VADStream);
    // (undocumented)
    recognize(buffer: AudioBuffer_2, language?: string | undefined): Promise<SpeechEvent>;
    // (undocumented)
    stream(language?: string | undefined): StreamAdapterWrapper;
}

// @public (undocumented)
class StreamAdapter_2 extends TTS {
    constructor(tts: TTS, tokenizer: SentenceTokenizer);
    // (undocumented)
    stream(): StreamAdapterWrapper_2;
    // (undocumented)
    synthesize(text: string): Promise<ChunkedStream>;
}

// @public (undocumented)
class StreamAdapterWrapper extends SpeechStream {
    constructor(stt: STT, vadStream: VADStream, language?: string | undefined);
    // (undocumented)
    close(wait?: boolean): Promise<void>;
    // (undocumented)
    next(): IteratorResult<SpeechEvent>;
    // (undocumented)
    pushFrame(frame: AudioFrame): void;
    // (undocumented)
    run(reject: (arg: Error) => void): Promise<void>;
}

// @public (undocumented)
class StreamAdapterWrapper_2 extends SynthesizeStream {
    constructor(tts: TTS, sentenceStream: SentenceStream);
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    flush(): Promise<void>;
    // (undocumented)
    next(): IteratorResult<SynthesisEvent>;
    // (undocumented)
    pushText(token: string): void;
    // (undocumented)
    run(reject: (arg: Error) => void): Promise<void>;
}

// @public (undocumented)
abstract class STT {
    constructor(streamingSupported: boolean);
    // (undocumented)
    abstract recognize(buffer: AudioBuffer_2, language?: string): Promise<SpeechEvent>;
    // (undocumented)
    abstract stream(language: string | undefined): SpeechStream;
    // (undocumented)
    get streamingSupported(): boolean;
}

declare namespace stt {
    export {
        STT,
        SpeechEvent,
        SpeechEventType,
        SpeechStream,
        SpeechData,
        StreamAdapter,
        StreamAdapterWrapper
    }
}
export { stt }

// @public (undocumented)
class SynthesisEvent {
    constructor(type: SynthesisEventType, audio?: SynthesizedAudio | undefined);
    // (undocumented)
    audio?: SynthesizedAudio;
    // (undocumented)
    type: SynthesisEventType;
}

// @public (undocumented)
enum SynthesisEventType {
    AUDIO = 1,
    FINISHED = 2,
    STARTED = 0
}

// @public (undocumented)
interface SynthesizedAudio {
    // (undocumented)
    data: AudioFrame;
    // (undocumented)
    text: string;
}

// @public (undocumented)
abstract class SynthesizeStream implements IterableIterator<SynthesisEvent> {
    // (undocumented)
    [Symbol.iterator](): SynthesizeStream;
    // (undocumented)
    abstract close(wait: boolean): Promise<void>;
    // (undocumented)
    markSegmentEnd(): void;
    // (undocumented)
    abstract next(): IteratorResult<SynthesisEvent>;
    // (undocumented)
    abstract pushText(token?: string): void;
}

// @public (undocumented)
export interface TranscriptionForwarder {
    // (undocumented)
    close(interrupt: boolean): Promise<void>;
    // (undocumented)
    currentCharacterIndex: number;
    // (undocumented)
    markAudioComplete(): void;
    // (undocumented)
    markTextComplete(): void;
    // (undocumented)
    pushAudio(frame: AudioFrame): void;
    // (undocumented)
    pushText(text: string): void;
    // (undocumented)
    start(): void;
}

// @public (undocumented)
abstract class TTS {
    constructor(streamingSupported: boolean);
    // (undocumented)
    abstract stream(): SynthesizeStream;
    // (undocumented)
    get streamingSupported(): boolean;
    // (undocumented)
    abstract synthesize(text: string): Promise<ChunkedStream>;
}

declare namespace tts {
    export {
        TTS,
        SynthesisEvent,
        SynthesisEventType,
        SynthesizedAudio,
        SynthesizeStream,
        StreamAdapter_2 as StreamAdapter,
        StreamAdapterWrapper_2 as StreamAdapterWrapper,
        ChunkedStream
    }
}
export { tts }

// @public (undocumented)
export abstract class VAD {
    abstract stream({ minSpeakingDuration, minSilenceDuration, paddingDuration, sampleRate, maxBufferedSpeech, }: {
        minSpeakingDuration: number;
        minSilenceDuration: number;
        paddingDuration: number;
        sampleRate: number;
        maxBufferedSpeech: number;
    }): VADStream;
}

// @public (undocumented)
export interface VADEvent {
    duration: number;
    samplesIndex: number;
    // (undocumented)
    speech: AudioFrame[];
    // (undocumented)
    type: VADEventType;
}

// @public (undocumented)
export enum VADEventType {
    // (undocumented)
    END_OF_SPEECH = 3,
    // (undocumented)
    SPEAKING = 2,
    // (undocumented)
    START_OF_SPEECH = 1
}

// @public (undocumented)
export abstract class VADStream implements IterableIterator<VADEvent> {
    // (undocumented)
    [Symbol.iterator](): VADStream;
    // (undocumented)
    abstract close(wait: boolean): Promise<void>;
    // (undocumented)
    abstract next(): IteratorResult<VADEvent>;
    // (undocumented)
    abstract pushFrame(frame: AudioFrame): void;
}

// @public (undocumented)
export const version = "0.1.0";

// @public
class Worker_2 {
    constructor(opts: WorkerOptions_2);
    // (undocumented)
    get activeJobs(): RunningJobInfo[];
    // (undocumented)
    close(): Promise<void>;
    // (undocumented)
    drain(timeout?: number): Promise<void>;
    // (undocumented)
    event: EventEmitter<[never]>;
    // (undocumented)
    get id(): string;
    // (undocumented)
    run(): Promise<void>;
    // (undocumented)
    simulateJob(roomName: string, participantIdentity?: string): Promise<void>;
}
export { Worker_2 as Worker }

// @public
export class WorkerError extends Error {
    constructor(msg?: string);
}

// @public
class WorkerOptions_2 {
    constructor({ agent, requestFunc, loadFunc, loadThreshold, numIdleProcesses, shutdownProcessTimeout, initializeProcessTimeout, permissions, agentName, workerType, maxRetry, wsURL, apiKey, apiSecret, host, port, logLevel, production, }: {
        agent: string;
        requestFunc?: (job: JobRequest) => Promise<void>;
        loadFunc?: () => Promise<number>;
        loadThreshold?: number;
        numIdleProcesses?: number;
        shutdownProcessTimeout?: number;
        initializeProcessTimeout?: number;
        permissions?: WorkerPermissions;
        agentName?: string;
        workerType?: JobType;
        maxRetry?: number;
        wsURL?: string;
        apiKey?: string;
        apiSecret?: string;
        host?: string;
        port?: number;
        logLevel?: string;
        production?: boolean;
    });
    // (undocumented)
    agent: string;
    // (undocumented)
    agentName: string;
    // (undocumented)
    apiKey?: string;
    // (undocumented)
    apiSecret?: string;
    // (undocumented)
    host: string;
    // (undocumented)
    initializeProcessTimeout: number;
    // (undocumented)
    loadFunc: () => Promise<number>;
    // (undocumented)
    loadThreshold: number;
    // (undocumented)
    logLevel: string;
    // (undocumented)
    maxRetry: number;
    // (undocumented)
    numIdleProcesses: number;
    // (undocumented)
    permissions: WorkerPermissions;
    // (undocumented)
    port: number;
    // (undocumented)
    production: boolean;
    // (undocumented)
    requestFunc: (job: JobRequest) => Promise<void>;
    // (undocumented)
    shutdownProcessTimeout: number;
    // (undocumented)
    workerType: JobType;
    // (undocumented)
    wsURL: string;
}
export { WorkerOptions_2 as WorkerOptions }

// @public
export class WorkerPermissions {
    constructor(canPublish?: boolean, canSubscribe?: boolean, canPublishData?: boolean, canUpdateMetadata?: boolean, canPublishSources?: TrackSource[], hidden?: boolean);
    // (undocumented)
    canPublish: boolean;
    // (undocumented)
    canPublishData: boolean;
    // (undocumented)
    canPublishSources: TrackSource[];
    // (undocumented)
    canSubscribe: boolean;
    // (undocumented)
    canUpdateMetadata: boolean;
    // (undocumented)
    hidden: boolean;
}

```
